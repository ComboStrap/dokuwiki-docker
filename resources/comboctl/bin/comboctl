#!/bin/bash
# Command utility for Dokuwiki

# flag
# e - Exit if any error
# u - Treat unset variables as an error when substituting
# o pipefail - the return value of a pipeline is the status of the last command to exit with a non-zero status or zero if no command exited with a non-zero status
# E - the ERR trap is inherited by shell functions
set -Eeuo pipefail


##########################################
# Standard/Library function
##########################################
CLI_NAME=$(basename "$0") # Name of the cli


# Echo a message
function echo_log() {

  echo -e "$CLI_NAME: ${1:-}"

}

# Print the error message $1
function echo_err() {
  RED='\033[0;31m'
  NC='\033[0m' # No Color
  #(>&2 echo -e "${RED}$1${NC}")
  echo_log "${RED}$1${NC}"
}

function finish() {
  echo_log "Script terminated\n"
}
trap finish EXIT

######################################
# Variable Init and Mandatory
######################################
if [ -z "$DOKUWIKI_HOME" ]; then
  echo_err "The env (DOKUWIKI_HOME) is mandatory"
  exit 1
fi;
DOKUWIKI_SAVE_DIR=${DOKU_DOCKER_SAVE_DIR:-$DOKUWIKI_HOME/data}
DOKUWIKI_PAGES_DIR="$DOKUWIKI_SAVE_DIR/pages"
DOKUWIKI_META_DIR="$DOKUWIKI_SAVE_DIR/meta"
DOKUWIKI_LOCKS_DIR="$DOKUWIKI_SAVE_DIR/locks"

######################################
# Command
######################################
function update_index(){

    echo_log "Updating the index"
    # If the volume has not enough space, the data sub-directory
    # may have not been created, we create them to not break the search
    mkdir -p "$DOKUWIKI_SAVE_DIR/attic"
    mkdir -p "$DOKUWIKI_SAVE_DIR/cache"
    mkdir -p "$DOKUWIKI_SAVE_DIR/index"
    mkdir -p "$DOKUWIKI_LOCKS_DIR"
    mkdir -p "$DOKUWIKI_SAVE_DIR/log"
    mkdir -p "$DOKUWIKI_SAVE_DIR/media_meta"
    mkdir -p "$DOKUWIKI_SAVE_DIR/media_attic"
    mkdir -p "$DOKUWIKI_META_DIR"
    mkdir -p "$DOKUWIKI_SAVE_DIR/tmp"

    php "$DOKUWIKI_HOME"/bin/indexer.php -q
}

# The first parameter is the git URI
#
# for ssh:
#    install_site git@github.com:ComboStrap/site-com-combostrap.git
#
# for https
#    install_site https://github.com:ComboStrap/site-com-combostrap
#
install_site() {

    echo_log "Installing the site: $1"
    # The default globbing in bash does not include filenames starting with a . (ie hidden files)
    # We want to include the `.gitignore` to avoid including the whole dokuwiki software
    shopt -s dotglob
    # safe directory to resolve `fatal: detected dubious ownership in repository at '/var/www/html'`
    git config --global --add safe.directory "$DOKUWIKI_HOME"
    # Create a temp directory without any conflict
    TEMP_DIR=$(mktemp -d)
    echo_log "Cloning the site into: $TEMP_DIR"
    git clone "$1" "$TEMP_DIR"
    echo_log "Moving the site into: $DOKUWIKI_HOME"
    find "$TEMP_DIR" -type f | while read -r FILE_PATH; do
        FILE_RELATIVE_PATH=${FILE_PATH#$TEMP_DIR}
        FILE_RELATIVE_DIR=$(dirname "$FILE_RELATIVE_PATH")
        mkdir -p "$DOKUWIKI_HOME/$FILE_RELATIVE_DIR"
        mv -f "$FILE_PATH" "$DOKUWIKI_HOME/$FILE_RELATIVE_PATH"
    done
    echo_log "Cleaning up"
    rm -rf "$TEMP_DIR"

}


# Clean the meta directory
# This script will clean the meta directory
# History in this thread: https://forum.dokuwiki.org/d/10570-meta-folder-full-of-spam/10
function clean_meta(){

  pagesDir=${1:-$DOKUWIKI_PAGES_DIR}
  metaDir=${2:-$DOKUWIKI_DOKUWIKI_META_DIR}

  echo_log "Cleaning the meta directory"
  # Iterate over each directory in meta
  find "$metaDir" -type d | while read -r dir; do
      # Get the relative path from metaDir
      relative_path="${dir#$metaDir}"

      # Check if the corresponding directory exists in pagesDir
      if [ ! -d "$pagesDir$relative_path" ]; then
          # If it doesn't exist, delete the directory in metaDir
          echo_log "  * Deleting dir: $dir"
          rm -rf "$dir"
      fi
  done

  # Iterate over each file in meta
  # A corresponding page file should exist in pages
  # Files extension in meta may be `meta`, `indexed` or `changes`
  find "$metaDir" -type FILE_PATH | while read -r metaFile; do

  	# Get the relative path from metaDir
    relative_path="${metaFile#$metaDir}"

    # Get away of the ext
  	relative_path_without_ext="${relative_path%.*}"

  	# Add txt
  	relative_page_path="${relative_path_without_ext}.txt"

    # Check if the corresponding page exists in pages
    if [ ! -f "$pagesDir$relative_page_path" ]; then
        # If it doesn't exist, delete the file in meta
        echo_log "  * Deleting file: $metaFile"
        rm -f "$metaFile"
    fi

  done

}

# Install Plugins
# if a plugins.dat file is found
install_plugins(){

    PLUGINS_FILE="${DOKU_DOCKER_SAVE_DIR}/combo/instance/plugins.dat"
    if [[ -f $PLUGINS_FILE ]]; then
      echo_log "Plugins Installation"
      grep -v '^#' "$PLUGINS_FILE" |
          while IFS=' ' read -r PLUGIN_NAME PLUGIN_ARCHIVE_URL
          do
            # If PLUGIN_NAME is empty, it's an empty line
            if [ -n "$PLUGIN_NAME" ]; then
              # Target Directory
              PLUGIN_TARGET_DIRECTORY="lib/plugins/$PLUGIN_NAME"
              if [[ ! -d $PLUGIN_TARGET_DIRECTORY ]]; then
                echo_log "  > Installing Plugin $PLUGIN_NAME ($PLUGIN_ARCHIVE_URL)"
                echo_log "    * Get the archive at ($PLUGIN_ARCHIVE_URL)"
                curl --fail -L "$PLUGIN_ARCHIVE_URL" -o "$PLUGIN_NAME.zip"
                echo_log "    * Create the directory"
                mkdir -p "$PLUGIN_TARGET_DIRECTORY"
                # > /dev/null -> no output
                echo_log "    * Unpack the archive"
                bsdtar --strip-components=1 -xvf "$PLUGIN_NAME.zip" -C "lib/plugins/$PLUGIN_NAME" > /dev/null 2>&1
                echo_log "    * Remove the archive"
                rm "$PLUGIN_NAME.zip"
              else
                echo_log "  > Plugin $PLUGIN_NAME already installed skipping"
              fi
            fi
          done
    else
        echo_log "No plugin files found, skipping installation"
    fi
}

function print_usage() {

  echo ""
  echo "Usage of the cli ${CLI_NAME}"
  echo ""
  echo "   ${CLI_NAME} command [--option[=value] ...]"
  echo ""
  echo "where command is one of:"
  echo "     * help            - this help"
  echo "     * index           - index the wiki"
  echo "     * install_site    - install a combo site"
  echo "     * install_plugins - install the plugins of a combo site"
  echo "     * clean           - maintenance script to clean the wiki"
  echo ""

}

# Lock Monitoring (It seems)
function lock() {

  cd "$DOKUWIKI_LOCKS_DIR" || exit 1
  while :; do
    ls -A1
    sleep 0.1
    clear
  done

}

COMMAND=""
declare -a OPTIONS
# Parsing
for arg in "$@"; do
  case "$arg" in
  --*)
    OPTIONS+=("$arg")
    shift
    ;;
  *)
    # Command or arg
    if [ "$COMMAND" == "" ]; then
        COMMAND=$1
        echo_log "Command ($COMMAND) found"
      else
        echo_log "Argument ($arg) found"
        ARGUMENTS+=("$arg")
    fi
    shift
    ;;
  esac
done

if [ -z "$COMMAND" ]; then
  echo_log 'No command was given, list chosen.'
  COMMAND='ls'
fi

echo_log
echo_log "${CLI_NAME^} ${COMMAND^}"
echo_log "-------------------------------------------"
echo_log ""
case ${COMMAND} in
index)
  update_index
  ;;
install_site)
  install_site "${ARGUMENTS[@]}"
  ;;
install_plugins)
  install_plugins
  ;;
help)
  print_usage
  ;;
*)
  echo_err "The command $COMMAND is unknown"
  print_usage
  exit 1
  ;;
esac
